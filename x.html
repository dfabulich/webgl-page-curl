<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.JS Page Curl</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #html-content {
            width: 100vw; 
            height: 100vh; 
            position: relative; 
            z-index: 1;
            display: flow-root; /* Prevent child margins from collapsing outside */
        }
        /* Canvas will overlay html-content */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2; /* Ensure canvas is on top of html-content */
            /* display: block; by default, or can be set in JS */
        }
    </style>
    <!-- html2canvas library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.js"></script>
</head>
<body>
    <div id="html-content"></div>
    <!-- Three.js canvas will be appended here by JS -->

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer;
        let planeMesh; // Holds red screenshot
        let blueScreenshotPlaneMesh; // Holds blue screenshot

        let redHTMLBodyContent = '';
        let blueHTMLBodyContent = '';

        const FRUSTUM_SIZE = 5; 
        let isAnimatingRedPlaneOut = false;

        async function init() {
            const htmlContentDiv = document.getElementById('html-content');
            try {
                const redResponse = await fetch('red.html');
                if (!redResponse.ok) throw new Error(`HTTP error loading red.html: ${redResponse.status}`);
                redHTMLBodyContent = await redResponse.text().then(text => new DOMParser().parseFromString(text, 'text/html').body.innerHTML);

                const blueResponse = await fetch('blue.html');
                if (!blueResponse.ok) throw new Error(`HTTP error loading blue.html: ${blueResponse.status}`);
                blueHTMLBodyContent = await blueResponse.text().then(text => new DOMParser().parseFromString(text, 'text/html').body.innerHTML);
                
                htmlContentDiv.innerHTML = redHTMLBodyContent;
            } catch (error) {
                console.error("Error loading HTML content:", error);
                htmlContentDiv.innerHTML = '<p style="color:red;">Error loading initial content.</p>';
            }

            scene = new THREE.Scene();
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(FRUSTUM_SIZE * aspect / -2, FRUSTUM_SIZE * aspect / 2, FRUSTUM_SIZE / 2, FRUSTUM_SIZE / -2, 0.01, 100);
            camera.position.z = 1;

            renderer = new THREE.WebGLRenderer({ alpha: true }); 
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement); // Canvas is now always in DOM, styled by CSS to overlay

            const planeGeometry = new THREE.PlaneGeometry(FRUSTUM_SIZE * aspect, FRUSTUM_SIZE);
            
            planeMesh = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            planeMesh.position.z = 0; 
            scene.add(planeMesh);

            blueScreenshotPlaneMesh = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            blueScreenshotPlaneMesh.position.z = -0.05; 
            scene.add(blueScreenshotPlaneMesh);

            window.addEventListener('resize', onWindowResize, false);

            window.go = async function() {
                if (isAnimatingRedPlaneOut) {
                    console.log("Animation already in progress.");
                    return;
                }
                if (!planeMesh || !blueScreenshotPlaneMesh) {
                    console.error("Critical screenshot planes not found. Re-initializing might be needed.");
                    return;
                }

                renderer.domElement.style.display = 'block'; // Ensure canvas is visible for the transition

                const htmlContentDiv = document.getElementById('html-content');

                try {
                    console.log("Starting transition...");

                    // 1. Capture red screenshot (from visible html-content)
                    htmlContentDiv.innerHTML = redHTMLBodyContent; // Ensure red is showing
                    await new Promise(resolve => requestAnimationFrame(resolve)); // Allow DOM to update if it was blue
                    console.log("Capturing red screenshot from #html-content...");
                    const redCanvas = await html2canvas(htmlContentDiv, { useCORS: true, logging: true, width: htmlContentDiv.offsetWidth, height: htmlContentDiv.offsetHeight, x:0, y:0, scrollX: -htmlContentDiv.scrollLeft, scrollY: -htmlContentDiv.scrollTop });
                    console.log("Red screenshot captured.");

                    // 2. Apply red screenshot to front canvas plane (makes canvas opaque with red content)
                    if (planeMesh.material.map) planeMesh.material.map.dispose();
                    planeMesh.material.dispose();
                    const redTexture = new THREE.CanvasTexture(redCanvas);
                    redTexture.needsUpdate = true;
                    planeMesh.material = new THREE.MeshBasicMaterial({ map: redTexture, transparent: true });
                    planeMesh.material.opacity = 1;
                    planeMesh.position.y = 0; 
                    console.log("Red screenshot applied to canvas plane.");

                    // 3. Switch underlying DOM to blue & capture blue screenshot (DOM is covered by canvas)
                    htmlContentDiv.innerHTML = blueHTMLBodyContent;
                    await new Promise(resolve => requestAnimationFrame(resolve)); 
                    console.log("Capturing blue screenshot from #html-content (now blue, but covered)...");
                    const blueCanvas = await html2canvas(htmlContentDiv, { useCORS: true, logging: true, width: htmlContentDiv.offsetWidth, height: htmlContentDiv.offsetHeight, x:0, y:0, scrollX: -htmlContentDiv.scrollLeft, scrollY: -htmlContentDiv.scrollTop });
                    console.log("Blue screenshot captured.");
                     const blueDataURL = blueCanvas.toDataURL('image/png'); // Keep this for debugging for a bit
                    console.log(`DEBUG: blueCanvas data URL length: ${blueDataURL.length}`);

                    // 4. Apply blue screenshot to back canvas plane
                    if (blueScreenshotPlaneMesh.material.map) blueScreenshotPlaneMesh.material.map.dispose();
                    blueScreenshotPlaneMesh.material.dispose();
                    const blueTexture = new THREE.CanvasTexture(blueCanvas);
                    blueTexture.needsUpdate = true;
                    blueScreenshotPlaneMesh.material = new THREE.MeshBasicMaterial({ map: blueTexture, transparent: true });
                    blueScreenshotPlaneMesh.material.opacity = 1;
                    console.log("Blue screenshot applied to canvas back plane.");
                                        
                    // 5. Animate red screenshot plane away
                    onWindowResize(); 
                    isAnimatingRedPlaneOut = true;
                    console.log("Starting red screenshot animation.");

                } catch (error) {
                    console.error("Error in go function:", error);
                    htmlContentDiv.innerHTML = redHTMLBodyContent; // Restore red content
                    renderer.domElement.style.display = 'none'; // Hide canvas on error
                }
            };

            animate();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = FRUSTUM_SIZE * aspect / -2;
            camera.right = FRUSTUM_SIZE * aspect / 2;
            camera.top = FRUSTUM_SIZE / 2;
            camera.bottom = FRUSTUM_SIZE / -2;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            const newPlaneGeometry = new THREE.PlaneGeometry(FRUSTUM_SIZE * aspect, FRUSTUM_SIZE);
            if (planeMesh) {
                planeMesh.geometry.dispose();
                planeMesh.geometry = newPlaneGeometry.clone();
            }
            if (blueScreenshotPlaneMesh) {
                blueScreenshotPlaneMesh.geometry.dispose();
                blueScreenshotPlaneMesh.geometry = newPlaneGeometry.clone();
            }
            newPlaneGeometry.dispose();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isAnimatingRedPlaneOut && planeMesh) {
                planeMesh.position.y += 0.05; 

                if ((planeMesh.position.y - FRUSTUM_SIZE / 2) > camera.top) {
                    console.log("Red screenshot animated out. Blue screenshot plane is visible on canvas.");
                    if (planeMesh.material.map) planeMesh.material.map.dispose();
                    planeMesh.material.dispose();
                    scene.remove(planeMesh);
                    planeMesh = null; 
                    
                    // Hide canvas, revealing the underlying blue HTML content
                    renderer.domElement.style.display = 'none'; 
                    document.getElementById('html-content').innerHTML = blueHTMLBodyContent; // Ensure blue is set if not already
                    console.log("Canvas hidden. Switched to final blue HTML content.");

                    if (blueScreenshotPlaneMesh) {
                        if (blueScreenshotPlaneMesh.material.map) blueScreenshotPlaneMesh.material.map.dispose();
                        blueScreenshotPlaneMesh.material.dispose();
                        scene.remove(blueScreenshotPlaneMesh);
                        blueScreenshotPlaneMesh = null;
                    }
                    isAnimatingRedPlaneOut = false;

                    // Prepare for next transition: re-create planes if they were nulled
                    // This might be better done at the start of go() or by not nulling them but just hiding/making transparent
                    const aspect = window.innerWidth / window.innerHeight;
                    const planeGeometry = new THREE.PlaneGeometry(FRUSTUM_SIZE * aspect, FRUSTUM_SIZE);
                    planeMesh = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
                    planeMesh.position.z = 0;
                    scene.add(planeMesh);

                    blueScreenshotPlaneMesh = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
                    blueScreenshotPlaneMesh.position.z = -0.05;
                    scene.add(blueScreenshotPlaneMesh);
                    planeGeometry.dispose();

                }
            }
            if (renderer.domElement.style.display !== 'none') { // Only render if canvas is visible
                 renderer.render(scene, camera);
            }
        }

        init();

    </script>
</body>
</html>
