<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.JS Page Curl</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #html-content {
            width: 100vw; 
            height: 100vh; 
            position: relative; 
            z-index: 1;
            display: flow-root; /* Prevent child margins from collapsing outside */
        }
        /* Canvas will overlay html-content */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2; /* Ensure canvas is on top of html-content */
            /* display: block; by default, or can be set in JS */
        }
    </style>
    <!-- html2canvas library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.js"></script>
</head>
<body>
    <div id="html-content"></div>
    <!-- Three.js canvas will be appended here by JS -->

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer;
        let planeMesh; // Holds red screenshot
        let blueScreenshotPlaneMesh; // Holds blue screenshot

        let redHTMLBodyContent = '';
        let blueHTMLBodyContent = '';

        const FRUSTUM_SIZE = 5; 
        let isAnimatingRedPlaneOut = false;

        let curlParameters = {
            curlAmount: 0.0, // 0 (flat) to target value (e.g., 1.0 or 1.5 for full curl and move away)
            curlRadius: 0.5, 
            curlAngle: Math.PI / 4, // Angle of the curl axis (45 degrees for bottom-right curl)
            animationSpeed: 0.01,
            curlTargetAmount: 1.5 // Value of curlAmount to consider animation complete
        };

        async function init() {
            const htmlContentDiv = document.getElementById('html-content');
            try {
                const redResponse = await fetch('red.html');
                if (!redResponse.ok) throw new Error(`HTTP error loading red.html: ${redResponse.status}`);
                redHTMLBodyContent = await redResponse.text().then(text => new DOMParser().parseFromString(text, 'text/html').body.innerHTML);

                const blueResponse = await fetch('blue.html');
                if (!blueResponse.ok) throw new Error(`HTTP error loading blue.html: ${blueResponse.status}`);
                blueHTMLBodyContent = await blueResponse.text().then(text => new DOMParser().parseFromString(text, 'text/html').body.innerHTML);
                
                htmlContentDiv.innerHTML = redHTMLBodyContent;
            } catch (error) {
                console.error("Error loading HTML content:", error);
                htmlContentDiv.innerHTML = '<p style="color:red;">Error loading initial content.</p>';
            }

            scene = new THREE.Scene();
            const aspect = window.innerWidth / window.innerHeight;
            const fov = 75; // Field of View
            camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
            // Adjust camera Z to fit FRUSTUM_SIZE plane in view
            camera.position.z = (FRUSTUM_SIZE / 2) / Math.tan(THREE.MathUtils.degToRad(fov / 2));

            renderer = new THREE.WebGLRenderer({ alpha: true }); 
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement); // Canvas is now always in DOM, styled by CSS to overlay

            const planeGeometry = new THREE.PlaneGeometry(FRUSTUM_SIZE * aspect, FRUSTUM_SIZE);
            
            planeMesh = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            planeMesh.position.z = 0; 
            scene.add(planeMesh);

            blueScreenshotPlaneMesh = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            blueScreenshotPlaneMesh.position.z = -0.05; 
            scene.add(blueScreenshotPlaneMesh);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 2);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);

            window.go = async function() {
                if (isAnimatingRedPlaneOut) {
                    console.log("Animation already in progress.");
                    return;
                }
                if (!planeMesh || !blueScreenshotPlaneMesh) {
                    console.error("Critical screenshot planes not found. Re-initializing might be needed.");
                    return;
                }

                renderer.domElement.style.display = 'block'; // Ensure canvas is visible for the transition

                const htmlContentDiv = document.getElementById('html-content');

                try {
                    console.log("Starting transition...");

                    // 1. Capture red screenshot (from visible html-content)
                    htmlContentDiv.innerHTML = redHTMLBodyContent; // Ensure red is showing
                    await new Promise(resolve => requestAnimationFrame(resolve)); // Allow DOM to update if it was blue
                    console.log("Capturing red screenshot from #html-content...");
                    const redCanvas = await html2canvas(htmlContentDiv, { useCORS: true, logging: true, width: htmlContentDiv.offsetWidth, height: htmlContentDiv.offsetHeight, x:0, y:0, scrollX: -htmlContentDiv.scrollLeft, scrollY: -htmlContentDiv.scrollTop });
                    console.log("Red screenshot captured.");

                    // 2. Apply red screenshot to front canvas plane (makes canvas opaque with red content)
                    if (planeMesh.material.map) planeMesh.material.map.dispose();
                    planeMesh.material.dispose();
                    const redTexture = new THREE.CanvasTexture(redCanvas);
                    redTexture.needsUpdate = true;
                    planeMesh.material = new THREE.MeshStandardMaterial({ 
                        map: redTexture, 
                        transparent: true, 
                        metalness: 0.2, 
                        roughness: 0.8 
                    });
                    planeMesh.material.opacity = 1;
                    planeMesh.position.y = 0; 
                    console.log("Red screenshot applied to canvas plane with StandardMaterial.");

                    // 3. Switch underlying DOM to blue & capture blue screenshot (DOM is covered by canvas)
                    htmlContentDiv.innerHTML = blueHTMLBodyContent;
                    await new Promise(resolve => requestAnimationFrame(resolve)); 
                    console.log("Capturing blue screenshot from #html-content (now blue, but covered)...");
                    const blueCanvas = await html2canvas(htmlContentDiv, { useCORS: true, logging: true, width: htmlContentDiv.offsetWidth, height: htmlContentDiv.offsetHeight, x:0, y:0, scrollX: -htmlContentDiv.scrollLeft, scrollY: -htmlContentDiv.scrollTop });
                    console.log("Blue screenshot captured.");
                     const blueDataURL = blueCanvas.toDataURL('image/png'); // Keep this for debugging for a bit
                    console.log(`DEBUG: blueCanvas data URL length: ${blueDataURL.length}`);

                    // 4. Apply blue screenshot to back canvas plane
                    if (blueScreenshotPlaneMesh.material.map) blueScreenshotPlaneMesh.material.map.dispose();
                    blueScreenshotPlaneMesh.material.dispose();
                    const blueTexture = new THREE.CanvasTexture(blueCanvas);
                    blueTexture.needsUpdate = true;
                    blueScreenshotPlaneMesh.material = new THREE.MeshBasicMaterial({ map: blueTexture, transparent: true });
                    blueScreenshotPlaneMesh.material.opacity = 1;
                    console.log("Blue screenshot applied to canvas back plane.");
                                        
                    // 5. Animate red screenshot plane away
                    onWindowResize(); 
                    isAnimatingRedPlaneOut = true;
                    console.log("Starting red screenshot animation.");

                } catch (error) {
                    console.error("Error in go function:", error);
                    htmlContentDiv.innerHTML = redHTMLBodyContent; // Restore red content
                    renderer.domElement.style.display = 'none'; // Hide canvas on error
                }
            };

            animate();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const fov = 75; // Ensure this matches init if used for z-calculation
            camera.aspect = aspect;
            // If fov or FRUSTUM_SIZE changes, camera.position.z might need re-evaluation here too
            // camera.position.z = (FRUSTUM_SIZE / 2) / Math.tan(THREE.MathUtils.degToRad(fov / 2));
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            // Ensure new planes are created with segments for deformation
            const newPlaneGeometry = new THREE.PlaneGeometry(FRUSTUM_SIZE * aspect, FRUSTUM_SIZE, 32, 32);
            if (planeMesh) {
                planeMesh.geometry.dispose();
                planeMesh.geometry = newPlaneGeometry.clone();
            }
            if (blueScreenshotPlaneMesh) {
                blueScreenshotPlaneMesh.geometry.dispose();
                blueScreenshotPlaneMesh.geometry = newPlaneGeometry.clone();
            }
            newPlaneGeometry.dispose();
        }

        // Pure function to calculate the new position of a single vertex for the curl
        function calculateCurledVertexPosition(originalX, originalY, geomWidth, geomHeight, amount, radius, angle) {
            const halfWidth = geomWidth / 2;
            const halfHeight = geomHeight / 2;
            const curlOriginX = halfWidth;
            const curlOriginY = -halfHeight;

            let new_x = originalX;
            let new_y = originalY;
            let new_z = 0; // Assuming plane starts flat at z=0 in its local space

            let dx = originalX - curlOriginX;
            let dy = originalY - curlOriginY;

            let x_rotated = dx * Math.cos(angle) + dy * Math.sin(angle);
            let y_rotated = -dx * Math.sin(angle) + dy * Math.cos(angle);

            const curlInfluenceLimit = amount * (Math.sqrt(geomWidth * geomWidth + geomHeight * geomHeight) * 0.75);

            if (x_rotated > 0 && x_rotated < curlInfluenceLimit) {
                let distToCurlLine = x_rotated;
                let y_falloff_distance = Math.abs(y_rotated);
                let curlStrengthFalloff = Math.max(0, 1 - (y_falloff_distance / (geomWidth * 0.5)));

                if (distToCurlLine < radius * Math.PI * curlStrengthFalloff) {
                    if (curlStrengthFalloff > 0.01) {
                        let currentRadius = radius * curlStrengthFalloff;
                        let theta = distToCurlLine / currentRadius;
                        let curled_x_rotated = currentRadius * Math.sin(theta);
                        let curled_z_rotated = currentRadius * (1 - Math.cos(theta));
                        curled_z_rotated += amount * geomHeight * 0.2; 

                        new_x = (curled_x_rotated * Math.cos(-angle) + y_rotated * Math.sin(-angle)) + curlOriginX;
                        new_y = (-curled_x_rotated * Math.sin(-angle) + y_rotated * Math.cos(-angle)) + curlOriginY;
                        new_z = curled_z_rotated;
                    }
                } else if (curlStrengthFalloff > 0.01) {
                    let currentRadius = radius * curlStrengthFalloff;
                    let lifted_z = 2 * currentRadius;
                    lifted_z += amount * geomHeight * 0.2; 
                    let tangent_extension = distToCurlLine - (radius * Math.PI * curlStrengthFalloff);
                    let curled_x_rotated = currentRadius * Math.sin(Math.PI) + tangent_extension;
                    new_x = (curled_x_rotated * Math.cos(-angle) + y_rotated * Math.sin(-angle)) + curlOriginX;
                    new_y = (-curled_x_rotated * Math.sin(-angle) + y_rotated * Math.cos(-angle)) + curlOriginY;
                    new_z = lifted_z;
                }
            }
            return { x: new_x, y: new_y, z: new_z };
        }

        // Function to deform the plane geometry for the curl effect
        function updatePageCurl(geometry, amount, radius, angle) {
            const positions = geometry.attributes.position;
            const vertex = new THREE.Vector3();
            const geomWidth = geometry.parameters.width;
            const geomHeight = geometry.parameters.height;

            for (let i = 0; i < positions.count; i++) {
                vertex.fromBufferAttribute(positions, i); // Get original x, y (z is implicitly 0 for fresh plane)
                
                const newPosition = calculateCurledVertexPosition(
                    vertex.x, 
                    vertex.y, 
                    geomWidth, 
                    geomHeight, 
                    amount, 
                    radius, 
                    angle
                );
                
                positions.setXYZ(i, newPosition.x, newPosition.y, newPosition.z);
            }
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isAnimatingRedPlaneOut && planeMesh) {
                curlParameters.curlAmount += curlParameters.animationSpeed;

                updatePageCurl(
                    planeMesh.geometry, 
                    curlParameters.curlAmount, 
                    curlParameters.curlRadius, 
                    curlParameters.curlAngle
                );

                if (curlParameters.curlAmount > curlParameters.curlTargetAmount) {
                    console.log("Red screenshot curled out. Blue screenshot plane is visible on canvas.");
                    if (planeMesh.material.map) planeMesh.material.map.dispose();
                    planeMesh.material.dispose();
                    scene.remove(planeMesh);
                    planeMesh = null; 
                    
                    // Hide canvas, revealing the underlying blue HTML content
                    renderer.domElement.style.display = 'none'; 
                    document.getElementById('html-content').innerHTML = blueHTMLBodyContent; // Ensure blue is set if not already
                    console.log("Canvas hidden. Switched to final blue HTML content.");

                    if (blueScreenshotPlaneMesh) {
                        if (blueScreenshotPlaneMesh.material.map) blueScreenshotPlaneMesh.material.map.dispose();
                        blueScreenshotPlaneMesh.material.dispose();
                        scene.remove(blueScreenshotPlaneMesh);
                        blueScreenshotPlaneMesh = null;
                    }
                    isAnimatingRedPlaneOut = false;
                    curlParameters.curlAmount = 0.0; // Reset for next time

                    // Prepare for next transition: re-create planes if they were nulled
                    // This might be better done at the start of go() or by not nulling them but just hiding/making transparent
                    const aspect = window.innerWidth / window.innerHeight;
                    const planeGeometry = new THREE.PlaneGeometry(FRUSTUM_SIZE * aspect, FRUSTUM_SIZE, 32, 32);
                    planeMesh = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
                    planeMesh.position.z = 0;
                    scene.add(planeMesh);

                    blueScreenshotPlaneMesh = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
                    blueScreenshotPlaneMesh.position.z = -0.05;
                    scene.add(blueScreenshotPlaneMesh);
                    // planeGeometry.dispose(); // Disposing the template geometry
                }
            }
            if (renderer.domElement.style.display !== 'none') { // Only render if canvas is visible
                 renderer.render(scene, camera);
            }
        }

        init();

    </script>
</body>
</html>
